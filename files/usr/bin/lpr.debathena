#!/usr/bin/python

# lpr.debathena
#
# Wrapper script that intelligently determines whether a command was
# intended for CUPS or LPRng and sends it off in the right direction

import os
import shlex
import sys

from debathena import printing

opts = {
    printing.SYSTEM_CUPS: {
        'lp': 'EU:cd:h:mn:o:q:st:H:P:i:',
        'lpq': 'EU:h:P:al',
        'lpr': 'EH:U:P:#:hlmo:pqrC:J:T:',
        'lprm': 'EU:h:P:',
    },
    printing.SYSTEM_LPRNG: {
        'lp': 'ckmprswBGYd:D:f:n:q:t:',
        'lpq': 'aAlLVcvP:st:D:',
        'lpr': 'ABblC:D:F:Ghi:kJ:K:#:m:NP:rR:sT:U:Vw:X:YZ:z1:2:3:4:',
        'lprm': 'aAD:P:VU:',
    },
}

def queue_opt(command):
    return '-P' if command != 'lp' else '-d'

def error(code, message):
    """Exit out with an error
    """
    sys.stderr.write(message)
    sys.exit(code)

def execCups(command, queue, args):
    """Pass the command and arguments on to the CUPS versions of the command
    """
    new_command = '/usr/bin/cups-%s' % command
    new_args = [command, '%s%s' % (queue_opt(command), queue)] + args
    os.execv(new_command, new_args)

def execLprng(command, queue, args):
    """Pass the command and arguments on to the LPRng versions of the command
    """
    new_command = '/usr/bin/mit-%s' % command
    new_args = [command, '%s%s' % (queue_opt(command), queue)] + args
    os.execv(new_command, new_args)

def translate_lprng_args_to_cups(command, args):
    # TODO yell at user if/when we decide that these args are deprecated

    # If getopt fails, something went very wrong -- _we_ generated this
    options, realargs = getopt.gnu_getopt(args, opts[printing.SYSTEM_LPRNG][command])
    cupsargs = []
    for (o, a) in options:
        if o in ('-a') and command == 'lpq':
            cupsargs += [('-a', a)]
        elif o in ('-b', '-l') and command == 'lpr':
            cupsargs += [('-l', a)]
        elif o in ('-h') and command == 'lpr':
            cupsargs += [('-h', a)]
        elif o in ('-J') and command == 'lpr':
            cupsargs += [('-J', a)]
        elif o in ('-K', '-#') and command == 'lpr':
            cupsargs += [('-#', a)]
        elif o in ('-P'):
            cupsargs += [('-P', a)]
        elif o in ('-T') and command == 'lpr':
            cupsargs += [('-T', a)]
        elif o in ('-U') and command == 'lpr':
            cupsargs += [('-U', a)]
        elif o in ('-v') and command == 'lpq':
            cupsargs += [('-l', a)]
        elif o in ('-Z') and command == 'lpr':
            if a == 'simplex':
                cupsargs += [('-o', 'sides=one-sided')]
            elif a == 'duplex':
                cupsargs += [('-o', 'sides=two-sided-long-edge')]
            elif a == 'duplexshort':
                cupsargs += [('-o', 'sides=two-sided-short-edge')]
            # TODO attempt to deal banner=staff
        elif o in ('-m') and command == 'lpr':
            # TODO figure out if CUPS can do mail/zephyr
            pass # Don't warn about this, we probably generated it
        else:
            sys.stderr.write("Warning: option %s%s not converted to CUPS\n"
                             % (o, a))
    joincupsargs = [o + a for o, a in cupsargs] + realargs
    sys.stderr.write("Using cups-%s %s\n" % (command, ' '.join(joincupsargs)))
    return joincupsargs

def main():
    # Remove the command name from the arguments when we extract it
    command = os.path.basename(sys.argv.pop(0))
    # Strip .debathena suffix if it's there
    if command[-10:] == '.debathena':
        command = command[:-10]

    args = sys.argv
    if command == 'lpr' and 'LPROPT' in os.environ:
        args = shlex.split(os.environ['LPROPT']) + args
        # If we leave LPROPT set, LPRng will count the options twice
        del os.environ['LPROPT']

    try:
        optinfos = [(s, opts[s][command]) for s in printing.SYSTEMS]
    except KeyError:
        error(1, ("\n"
                  "Error: this script was called as %s, when it must be called as\n"
                  "one of lpr, lpq, lprm, or lp\n"
                  "\n" % command))

    queue = printing.get_default_printer()
    argstyle = None
    try:
        argstyle, options, arguments = printing.parse_args(args, optinfos)

        # Find the queue specified in the arguments
        queue_args, options = printing.extract_opt(options, queue_opt(command))
        if queue_args:
            # The last queue specified wins
            queue = queue_args[-1][-1]

        # Deal with zephyr notifications
        if command == 'lpr':
            zephyr_args, options = printing.extract_opt(options, ['-N'])
            if not zephyr_args and os.environ.get('ATHENA_USER'):
                options.append(('-m', 'zephyr%' + os.environ['ATHENA_USER']))

        # Now that we've sliced up the arguments, put them back
        # together
        args = [o + a for o, a in options] + arguments
    except ValueError:
        # parse_args returned None, so we learned nothing. We'll just
        # go with the default queue
        pass

    if not queue:
        # We tried and couldn't figure it out, so not our problem
        error(2, ("\n"
                  "No default printer configured. Specify a -P option, or configure a\n"
                  "default printer via e.g. System | Administration | Printing.\n"
                  "\n"))

    system, server, queue = printing.find_queue(queue)
    if system == printing.SYSTEM_CUPS:
        if argstyle == printing.SYSTEM_LPRNG:
            args = translate_lprng_args_to_cups(command, args)
        if server:
            os.environ['CUPS_SERVER'] = server
        execCups(command, queue, args)
    elif system == printing.SYSTEM_LPRNG:
        execLprng(command, queue, args)
    else:
        error(1, ("\n"
                  "Error: the print queue %s uses an unknown printing infrastructure\n"
                  "\n" % queue))

if __name__ == '__main__':
    main()
