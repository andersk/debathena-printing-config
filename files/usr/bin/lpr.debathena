#!/usr/bin/python

# lpr.debathena
#
# also lp.debathena, lpq.debathena, and lprm.debathena
#
# Wrapper script that intelligently determines whether a command was
# intended for should go to CUPS or LPRng and sends it off in the
# right direction

import errno
import hesiod
import getopt
import os
import sys
from subprocess import call, PIPE

opts = {
    'cups': {
        'cancel': 'EU:ah:u:',
        'lp': 'EU:cd:h:mn:o:q:st:H:P:i:',
        'lpq': 'EU:h:P:al',
        'lpr': 'EH:U:P:#:hlmo:pqrC:J:T:',
        'lprm': 'EU:h:P:'
    },
    'lprng': {
        'cancel': 'aAD:P:VU:',
        'lp': 'ckmprswBGYd:D:f:n:q:t:',
        'lpq': 'aAlLVcvP:st:D:',
        'lpr': 'ABblC:D:F:Ghi:kJ:K:#:m:P:rR:sT:U:Vw:X:YZ:1:2:3:4:',
        'lprm': 'aAD:P:VU:'
    }
}

preflist = {
    'cups': ['cups', 'lprng'],
    'lprng': ['lprng', 'cups']
}

def error(code, message):
    """Exit out with an error
    """
    sys.stderr.write(message)
    sys.exit(code)

def run(name, command, rargs):
    """Given a path to a command and the rest of the arguments, exec it
    """
    os.execv(command, [name] + rargs)

def returnCode(*command):
    """Get the return code of a command and throw away the output
    """
    return call(command, stdout=PIPE, stderr=PIPE)

def cupsQueueExists(queue):
    """Test if queue name exists as a CUPS queue
    """
    return returnCode('/usr/bin/lpq.debathena-orig', '-P%s' % queue) == 0

def lprngQueueExists(queue):
    """Test if queue name exists as an LPRng queue
    """
    try:
        h = hesiod.Lookup(queue, 'pcap')
        return len(h.results) > 0
    except IOError, e:
        if e.errno in (errno.ENOENT, errno.EMSGSIZE):
            return None
        else:
            raise

def useCups(command, queue, args):
    """If queue exists as a CUPS queue, pass the command and arguments on to the
    CUPS versions of the command
    """
    if queue == None or cupsQueueExists(queue) or not lprngQueueExists(queue):
        new_command = '/usr/bin/%s.debathena-orig' % command
        run(command, new_command, args)

def useLprng(command, queue, args):
    """If queue exists as an LPRng queue, pass the command and arguments on to
    the LPRng versions of the command
    """
    if queue == None or lprngQueueExists(queue) or not cupsQueueExists(queue):
        new_command = '/usr/bin/mit-%s' % command
        run(command, new_command, args)

def getPrintQueue(command, args, preference):
    """Given argv, extract the printer name, using knowledge of the possible
    command line options for both the CUPS and LPRng versions of the command
    that this script was called as. Also, return whether the command line
    options imply a particular version of the command.
    """
    for version in preflist[preference]:
        try:
            # Get the set of options that correspond to the command that this
            # script was invoked as
            cmd_opts = opts[version][command]
        except KeyError:
            error(1, """
Error: this script was called as %s, when it must be called as
one of lpr, lpq, lprm, lp, or cancel

""" % command)

        # Attempt to parse it with the current version of this command
        try:
            options, args = getopt.gnu_getopt(args, cmd_opts)
        except getopt.GetoptError:
            # That's the wrong version, so try the next one.
            continue

        for o, a in options:
            if o == '-P':
                return (version, a)
        if command == 'cancel' and len(args) > 0:
            return (version, args[0])
        # Since we've successfully getopt'd, don't try any other versions,
        # but do note that we like this version.
        preference = version
        break

    # This script was invoked with argv[0] set to something it doesn't know
    # about. In that case, use our preferred version.
    default = os.getenv('PRINTER')
    if default:
        return (preference, default)
    try:
        h = hesiod.Lookup(os.uname()[1], 'cluster')
        for result in h.results:
            (key, value) = result.split(None, 1)
            if key == 'lpr':
                return (preference, value)
    except IOError, e:
        if e.errno in (errno.ENOENT, errno.EMSGSIZE):
            pass
        else:
            raise

    return (preference, None)

if __name__ == '__main__':
    # Remove the command name from the arguments when we extract it
    command = os.path.basename(sys.argv.pop(0))
    # Figure out whether to prefer LPRng or CUPS. If we can't decide based on
    # the config file, then we're going with CUPS
    try:
        # Ok, yeah, the lower might be going a little overboard, but I don't
        # like giving users room to screw things up :)
        preference = open('/etc/debathena-printing.conf').read().\
            strip().lower()
    except IOError:
        preference = 'cups'

    # Determine if the arguments prefer one version of this command,
    # For instance, "lpq -h cups.csail -P xerox5" wants cups-lpq
    (preference, queue) = getPrintQueue(command, sys.argv, preference)

    fns = {'cups': [useCups, useLprng],
           'lprng': [useLprng, useCups]}
    fn_args = [command, queue, sys.argv]
    for fn in fns[preference]:
        fn(*fn_args)
